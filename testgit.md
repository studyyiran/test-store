1 not 1 is 2222 我处理了冲突  master继续做一些开发  并且直接提交 偷懒没做hotfix的分支  
mater继续开发
mater继续开发
1 2 3 4 5
1 2 3 4 5
我在开发的过程中.
hotfix上面发生了提交.并且master也接纳了.

我有两个策略
1)将master上来.
2)继续开发,不理会.

我觉得正确的做法,肯定是rebase master上面的变更.

a master b 是将b的特性分支,吸纳到a上面

我先尝试的方式是:
    直接将master merge过来.
    然后我继续开发
    
这种方式做完了,我的感觉是.
mater merge feature 

feature merge master
最终的结果是一样的.并没有区别.
哦对了,是有区别的.他们代码的结果一样.
a merge b a动b不动.merge是一个主动行为,将他人的代码吸收过来.


他们预期描述的是,我将最新的master代码合并到了开发分支上,这样我能够继续开发.

而这次的操作如果用rebase呢?

让我们再了解下rebase
rebase是一种回响.
当a rebase b的时候.我们仍然是a动b不动.
1)找到共同基底
2)a先比较,将差异暂存
3)直接切到b的最后一次提交
4)将a在这次提交之后重做.
5)得到新的a?

这样是不是有提交时间的问题,这样不是相当于a的所有提交都被重做了?
不.我们并没有新作提交,我觉得它更像是一个批量的cherry-pick操作.

继续开发

rebase的操作是一种变节操作,他的确摒弃了自己的肉身,在另外一个精神世界进行的重做.


复习
远程分支只是普通的分支.我并不虚.
当发生hotfix之后,是否合并,决定权在我的手里.

我接下来要测试几个东西.
1)我先仅仅复习merge.我通过git fetch

1)git pull 和 git pull--rebase的区别
我为了研究rebase是不是一种好操作.

我发现,当hitfix之后,无论你是
先merge

还是
先开发,最后merge.

结果应该是一样的.

并且我发现,两个分支,
在a merge b
b merge a 之后
他们就没有任何区别了.这两个分支.(我目前认为如此.他们无论是结果 还是提交记录 都应该是一样的.一样的.)


还发现一个特性。
merge在做冲突解决的时候，只需要一次。
而rebase。
他的本质很恐怖。他是蜕皮。
他会将原本的本质改写，重做，像修改记忆一样。准确的说，是植入一段别人的记忆。

因此执行rebase之后，你不好找到上一次提交，因为他抹掉了上一次提交的痕迹，并且换上了一些新的痕迹。